package eu.training.collections;

public class TheBigO {
// Big O notation is a system for measuring the rate of growth of an algorithm.
// Big O notation mathematically describes the complexity of an algorithm in terms of time and space
// O(n) -> O stands for the order of the function or growth rate and n is the actual mathematical function
// O(1) -> constant, the execution time of the algorithm does not depend on the size of the input. Its execution time is constant. Ex. accesing array index, inserting node in a Linked List, pushing and poping on Stack.
// O(log n) -> logarithmic(binary search), refers to an algorithm that runs in proportionally to the logarithm of the input size.
// O(n) -> linear, describes an algorithm or program who’s complexity will grow in direct proportion to the size of the input data. Ex. for or a while loop
// O(n^2) || O(N²) -> quadratic, represents an algorithm whose performance is directly proportional to the squared size of the input data set. Ex. loop withing a loop, bubble sort, insertion sort.
// O(2^n) -> exponential, denotes an algorithm whose growth doubles with each addition to the input data set. Ex. recursive calls over n and looping over c in the function.
// O(n!) -> factorial, algorithms will execute in n factorial time per every new operation. Ex. looping over n and recursive call in the loop to n-1.
// Recursion -> is the technique of making a function/method call itself.




}
